{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#unipressed","title":"Unipressed","text":"<p>Please visit the project website for more comprehensive documentation.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>Unipressed (Uniprot REST) is an API client for the protein database Uniprot. It provides thoroughly typed and documented code to ensure your use of the library is easy, fast, and correct!</p>"},{"location":"#example","title":"Example","text":"<p>Let's say we're interested in very long proteins that are encoded within a chloroplast, in any organism:</p> <pre><code>from unipressed import UniprotkbClient\n\nfor record in UniprotkbClient.search(\n    query={\n        \"and_\": [\n            {\"organelle\": \"chloroplast\"},\n            {\"length\": (5000, \"*\")}\n        ]\n    },\n    fields=[\"length\", \"gene_names\"]\n).each_record():\n    display(record)\n</code></pre> <pre>\n{\n    'primaryAccession': 'A0A088CK67',\n    'genes': [\n        {\n            'geneName': {\n                'evidences': [{'evidenceCode': 'ECO:0000313', 'source': 'EMBL', 'id': 'AID67672.1'}],\n                'value': 'ftsH'\n            }\n        }\n    ],\n    'sequence': {'length': 5242}\n}\n</pre>"},{"location":"#advantages","title":"Advantages","text":"<ul> <li>Detailed type hints for autocompleting queries as you type</li> <li>Autocompletion for return fields</li> <li>Documentation for each field</li> <li>Automatic results parsing, for <code>json</code>, <code>tsv</code>, <code>list</code>, and <code>xml</code></li> <li>Built-in pagination, so you don't have to handle any of that yourself!</li> <li>Most of the API is automatically generated, ensuring very rapid updates whenever the API changes</li> <li>Thoroughly tested, with 41 unit tests and counting!</li> </ul>"},{"location":"#usage","title":"Usage","text":""},{"location":"#installation","title":"Installation","text":"<p>If you're using poetry: <pre><code>poetry add unipressed\n</code></pre></p> <p>Otherwise: <pre><code>pip install unipressed\n</code></pre></p>"},{"location":"#dataset-clients","title":"Dataset Clients","text":"<p>The <code>unipressed</code> module exports a client object for each UniProt dataset:</p> <pre><code>from unipressed import UniprotkbClient, UniparcClient\n</code></pre> <p>With one of these clients, you can search the dataset:</p> <pre><code>records = UniprotkbClient.search({\n    \"length\": (5000, 6000)\n}).each_record()\n\n# Show the first record\nnext(records)\n</code></pre> <pre>\n{\n    'entryType': 'UniProtKB reviewed (Swiss-Prot)',\n    'primaryAccession': 'Q96RW7',\n    'secondaryAccessions': ...,\n    'uniProtkbId': 'HMCN1_HUMAN',\n    'entryAudit': ...,\n    'annotationScore': 5.0,\n    'organism': ...,\n    'proteinExistence': '1: Evidence at protein level',\n    'proteinDescription': ...,\n    'genes': ...,\n    'comments': ...,\n    'features': ...,\n    'keywords': ...,\n    'references': ...,\n    'uniProtKBCrossReferences': ...,\n    'sequence': ...,\n    'extraAttributes': ...\n}\n</pre> <p>You can request a single record by ID:</p> <pre><code>UniprotkbClient.fetch_one(\"Q96RW7\")\n</code></pre> <pre>\n{\n    'entryType': 'UniProtKB reviewed (Swiss-Prot)',\n    'primaryAccession': 'Q96RW7',\n    'secondaryAccessions': ...,\n    'uniProtkbId': 'HMCN1_HUMAN',\n    'entryAudit': ...,\n    'annotationScore': 5.0,\n    'organism': ...,\n    'proteinExistence': '1: Evidence at protein level',\n    'proteinDescription': ...,\n    'genes': ...,\n    'comments': ...,\n    'features': ...,\n    'keywords': ...,\n    'references': ...,\n    'uniProtKBCrossReferences': ...,\n    'sequence': ...,\n    'extraAttributes': ...\n}\n</pre> <p>You can also request multiple records:</p> <pre><code>UniprotkbClient.fetch_many([\"A0A0C5B5G6\", \"A0A1B0GTW7\"])\n</code></pre> <pre>\n[\n    {\n        'entryType': 'UniProtKB reviewed (Swiss-Prot)',\n        'primaryAccession': 'A0A0C5B5G6',\n        'uniProtkbId': 'MOTSC_HUMAN',\n        'entryAudit': ...,\n        'annotationScore': 5.0,\n        'organism': ...,\n        'proteinExistence': '1: Evidence at protein level',\n        'proteinDescription': ...,\n        'genes': ...,\n        'comments': ...,\n        'features': ...,\n        'geneLocations': ...,\n        'keywords': ...,\n        'references': ...,\n        'uniProtKBCrossReferences': ...,\n        'sequence': ...,\n        'extraAttributes': ...\n    },\n    {\n        'entryType': 'UniProtKB reviewed (Swiss-Prot)',\n        'primaryAccession': 'A0A1B0GTW7',\n        'secondaryAccessions': ...,\n        'uniProtkbId': 'CIROP_HUMAN',\n        'entryAudit': ...,\n        'annotationScore': 5.0,\n        'organism': ...,\n        'proteinExistence': '1: Evidence at protein level',\n        'proteinDescription': ...,\n        'genes': ...,\n        'comments': ...,\n        'features': ...,\n        'keywords': ...,\n        'references': ...,\n        'uniProtKBCrossReferences': ...,\n        'sequence': ...,\n        'extraAttributes': ...\n    }\n]\n</pre>"},{"location":"#id-mapping","title":"ID Mapping","text":"<p>Unipressed also provides one other unique client, which is designed for mapping identifiers. You provide the source and destination database (both of which will autocomplete in VS Code), and a list of identifiers for the source database.</p> <pre><code>from unipressed import IdMappingClient\nrequest = IdMappingClient.submit(\n    source=\"UniProtKB_AC-ID\", dest=\"Gene_Name\", ids={\"A1L190\", \"A0JP26\", \"A0PK11\"}\n)\nlist(request.each_result())\n</code></pre> <pre>\n[\n    {'from': 'A1L190', 'to': 'SYCE3'},\n    {'from': 'A0PK11', 'to': 'CLRN2'},\n    {'from': 'A0JP26', 'to': 'POTEB3'}\n]\n</pre> <p>Note that, if you submit a large number of IDs, you might need to add a <code>sleep()</code> call between submitting the request and retrieving the results.</p>"},{"location":"#query-syntax","title":"Query Syntax","text":"<p>The query syntax refers to the values you pass in to the <code>query</code> argument of the <code>search()</code> method.</p> <p>In general, you can't go wrong by following the type hints. I strongly recommend using something like <code>pylance</code> for Visual Studio Code, which will provide automatic completions and warn you when you have used the wrong syntax.</p> <p>If you already know how to use the Uniprot query language, you can always just input your queries as strings:</p> <pre><code>UniprotkbClient.search(query=\"(gene:BRCA*) AND (organism_id:10090)\")\n</code></pre> <p>However, if you want some built-in query validation and code completion using Python's type system, then you can instead use a dictionary. The simplest query is a dictionary with a single key: </p> <pre><code>UniprotkbClient.search(query={\"family\": \"kinase\"})\n</code></pre> <p>You can compile more complex queries using the <code>and_</code>, <code>or_</code> and <code>not_</code> keys. These first two operators take a list of query dictionaries: </p> <pre><code>UniprotkbClient.search(query={\n    \"and_\": [\n        {\"family\": \"kinase\"},\n        {\"organism_id\": \"9606\"},\n    ]\n})\n</code></pre> <p>Most \"leaf\" nodes of the query tree (ie those that aren't operators like <code>and_</code>) are strings, integers or floats, which you input as normal Python literals as you can see above. For string fields, you also have access to wildcards, namely the <code>*</code> character.  For example, if you want every human protein belonging to a gene whose name starts with <code>PRO</code>, you could use:</p> <pre><code>UniprotkbClient.search(query={\n    \"and_\": [\n        {\"gene\": \"PRO*\"},\n        {\"organism_id\": \"9606\"},\n    ]\n})\n</code></pre> <p>A few query fields are ranges, which you input using a tuple with two elements, indicating the start and end of the range. If you use the literal <code>\"*\"</code> then you can leave the range open at one end.  For example, this query returns any protein that is in the range \\([5000, \\infty)\\)</p> <pre><code>UniprotkbClient.search(query={\"length\": (5000, \"*\")})\n</code></pre> <p>Finally, a few query fields take dates. These you input as a Python <code>datetime.date</code> object. For example, to find proteins added to UniProt since July 2022, we would do:</p> <pre><code>from datetime import date\n\nUniprotkbClient.search(query={\"date_created\": (date(2022, 7, 1), \"*\")})\n</code></pre>"},{"location":"#use-with-visual-studio-code","title":"Use with Visual Studio Code","text":"<p>To get VS Code to offer suggestions, press the <code>Trigger Suggest</code> shortcut which is usually bound to <code>Ctrl + Space</code>. In particular, code completion generally won't work until you open a string literal using a quotation mark.</p> <p>Secondly, to get live access to the documentation, you can either use the <code>Show Hover</code> shortcut, which is usually bound to <code>Ctrl + K, Ctrl + I</code>, or you can install the <code>docs-view</code> extension, which lets you view the docstrings in the sidebar without interfering with your code.</p>"},{"location":"#screenshots","title":"Screenshots","text":"Autocompletion for query keys  Autocompletion for query values Documentation for almost all types  Autocompletion for return fields"},{"location":"#api","title":"API","text":""},{"location":"#unipressed.dataset.core.DatasetClient","title":"<code>unipressed.dataset.core.DatasetClient</code>","text":"<p>The base class for all UniProt dataset clients. All methods documented here are available in any of the subclasses. This is a static class that you will never need to instantiate.</p>"},{"location":"#unipressed.dataset.core.DatasetClient.fetch_one","title":"<code>fetch_one(id: str, format: str = 'json', parse: bool = True) -&gt; JsonResultType | IOBase</code>  <code>classmethod</code>","text":"<p>Fetches a single record from this dataset using its ID.</p> <p>Parameters:</p> <ul> <li> <code>id</code>           \u2013            <p>The ID of the record to fetch. The format of this will depend on the dataset.</p> </li> <li> <code>format</code>           \u2013            <p>The format of the result. The available options will depend on the subclass you are using, but the type checker/autocomplete will enforce available options.</p> </li> <li> <code>parse</code>           \u2013            <p>If true, parse the result into a JSON dictionary. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>JsonResultType | IOBase</code>           \u2013            <p>If parse is True, a dictionary. Otherwise, a file object containing the results in the specified format.</p> </li> </ul>"},{"location":"#unipressed.dataset.core.DatasetClient.search","title":"<code>search(query: QueryType, format: FormatType | Literal['json'] = 'json', fields: Iterable[FieldsType] | None = None, size: int = 500, include_isoform: bool = True) -&gt; Search[QueryType, JsonResultType, FieldsType, FormatType]</code>  <code>classmethod</code>","text":"<p>Creates an object that can be used to perform a search query over this dataset. Refer to the unipressed.dataset.search.Search reference for more information on how to use it.</p>"},{"location":"#unipressed.dataset.core.FetchManyClient","title":"<code>unipressed.dataset.core.FetchManyClient</code>","text":"<p>               Bases: <code>DatasetClient[QueryType, JsonResultType, FieldsType, FormatType]</code></p> <p>Dataset subclass for datasets that can be queried by multiple IDs. Not all datasets support this.</p>"},{"location":"#unipressed.dataset.core.FetchManyClient.fetch_many","title":"<code>fetch_many(ids: Iterable[str], format: FormatType | Literal['json'] = 'json', parse: bool = True) -&gt; Iterable[JsonResultType] | IOBase</code>  <code>classmethod</code>","text":"<p>Fetches multiple records using their accessions.</p> <p>Parameters:</p> <ul> <li> <code>ids</code>           \u2013            <p>The accessions to query</p> </li> <li> <code>format</code>           \u2013            <p>The format to return the records. Defaults to \"json\".</p> </li> <li> <code>parse</code>           \u2013            <p>Only supported for JSON. If True, parses the result instead of returning a raw file. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterable[JsonResultType] | IOBase</code>           \u2013            <p>If parse is True, a list of dictionaries. Otherwise, a file object containing the results in the specified format.</p> </li> </ul>"},{"location":"#unipressed.dataset.search.Search","title":"<code>unipressed.dataset.search.Search</code>  <code>dataclass</code>","text":"<p>Class coordinating search requests. Generally you shouldn't instantiate this manually, but should rather use unipressed.DatasetClient.search to do so.</p>"},{"location":"#unipressed.dataset.search.Search.each_response","title":"<code>each_response() -&gt; Iterable[requests.Response]</code>","text":"<p>Returns a generator of <code>requests.Response</code> objects, one for each page of the result.</p>"},{"location":"#unipressed.dataset.search.Search.each_page","title":"<code>each_page() -&gt; Iterable[TextIO]</code>","text":"<p>Returns a generator of unzipped file objects, one for each page of the result.</p>"},{"location":"#unipressed.dataset.search.Search.each_record","title":"<code>each_record() -&gt; Iterable[Any]</code>","text":"<p>Returns a generator of records, which are defined by the format field of the original request. For example, with <code>format=\"json\"</code>, this will be an iterator over dictionaries parsed from JSON.</p>"},{"location":"#unipressed.IdMappingClient","title":"<code>unipressed.IdMappingClient</code>  <code>dataclass</code>","text":"<p>Client for submitting requests to convert between identifiers.</p>"},{"location":"#unipressed.IdMappingClient.submit","title":"<code>submit(source: str, dest: str, ids: Iterable[str], taxon_id: int | None = None) -&gt; IdMappingJob</code>  <code>classmethod</code>","text":"<p>Submits this ID mapping request to the UniProt server, and returns a new object that can be used to access the results</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>str</code>)           \u2013            <p>Name of the database from which the ids originate</p> </li> <li> <code>dest</code>               (<code>str</code>)           \u2013            <p>Name of the database that the IDs will be converted to</p> </li> <li> <code>ids</code>               (<code>Iterable[str]</code>)           \u2013            <p>Set of IDs to convert</p> </li> <li> <code>taxon_id</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Optionally, a UniProt taxon ID to restrict the results to. For example, you can use <code>4932</code> to restrict the results to Baker's yest (https://www.uniprot.org/taxonomy/4932).</p> </li> </ul>"},{"location":"#unipressed.id_mapping.core.IdMappingJob","title":"<code>unipressed.id_mapping.core.IdMappingJob</code>  <code>dataclass</code>","text":"<p>Object that tracks the status and results of an ID mapping request that has been sent to the UniProt server.</p>"},{"location":"#unipressed.id_mapping.core.IdMappingJob.each_result","title":"<code>each_result() -&gt; Iterable[IdMappingResult]</code>","text":"<p>Returns a generator over dictionaries of results, one for each input ID.</p>"},{"location":"#unipressed.id_mapping.core.IdMappingJob.get_status","title":"<code>get_status() -&gt; UniprotStatus</code>","text":"<p>Returns a string describing the status of the job (ie if it has completed or not).</p>"},{"location":"#unipressed.id_mapping.core.IdMappingResult","title":"<code>unipressed.id_mapping.core.IdMappingResult = TypedDict('IdMappingResult', {'from': str, 'to': str})</code>  <code>module-attribute</code>","text":""},{"location":"#unipressed.ArbaClient","title":"<code>unipressed.ArbaClient</code>","text":"<p>               Bases: <code>DatasetClient[ArbaQuery, Mapping[str, Any], ArbaFields, ArbaFormats]</code></p>"},{"location":"#unipressed.CitationsClient","title":"<code>unipressed.CitationsClient</code>","text":"<p>               Bases: <code>DatasetClient[CitationsQuery, Mapping[str, Any], CitationsFields, CitationsFormats]</code></p>"},{"location":"#unipressed.DiseasesClient","title":"<code>unipressed.DiseasesClient</code>","text":"<p>               Bases: <code>DatasetClient[DiseasesQuery, Mapping[str, Any], DiseasesFields, DiseasesFormats]</code></p>"},{"location":"#unipressed.KeywordsClient","title":"<code>unipressed.KeywordsClient</code>","text":"<p>               Bases: <code>DatasetClient[KeywordsQuery, Mapping[str, Any], KeywordsFields, KeywordsFormats]</code></p>"},{"location":"#unipressed.LocationsClient","title":"<code>unipressed.LocationsClient</code>","text":"<p>               Bases: <code>DatasetClient[LocationsQuery, Mapping[str, Any], LocationsFields, LocationsFormats]</code></p>"},{"location":"#unipressed.ProteomesClient","title":"<code>unipressed.ProteomesClient</code>","text":"<p>               Bases: <code>DatasetClient[ProteomesQuery, Mapping[str, Any], ProteomesFields, ProteomesFormats]</code></p>"},{"location":"#unipressed.TaxonomyClient","title":"<code>unipressed.TaxonomyClient</code>","text":"<p>               Bases: <code>FetchManyClient[TaxonomyQuery, Mapping[str, Any], TaxonomyFields, TaxonomyFormats]</code></p>"},{"location":"#unipressed.UniparcClient","title":"<code>unipressed.UniparcClient</code>","text":"<p>               Bases: <code>FetchManyClient[UniparcQuery, Mapping[str, Any], UniparcFields, UniparcFormats]</code></p>"},{"location":"#unipressed.UniprotkbClient","title":"<code>unipressed.UniprotkbClient</code>","text":"<p>               Bases: <code>FetchManyClient[UniprotkbQuery, Mapping[str, Any], UniprotkbFields, UniprotkbFormats]</code></p>"},{"location":"#unipressed.UnirefClient","title":"<code>unipressed.UnirefClient</code>","text":"<p>               Bases: <code>FetchManyClient[UnirefQuery, Mapping[str, Any], UnirefFields, UnirefFormats]</code></p>"},{"location":"#unipressed.UniruleClient","title":"<code>unipressed.UniruleClient</code>","text":"<p>               Bases: <code>DatasetClient[UniruleQuery, Mapping[str, Any], UniruleFields, UniruleFormats]</code></p>"},{"location":"#changelog","title":"Changelog","text":""},{"location":"#140","title":"1.4.0","text":""},{"location":"#added","title":"Added","text":"<ul> <li>The <code>taxon_id</code> argument to <code>IdMapper.submit</code> [#36]</li> <li>Detailed type annotations for <code>IdMapper.submit</code>, that enforce only certain pairs of <code>source</code>/<code>dest</code> databases</li> </ul>"},{"location":"#changed","title":"Changed","text":"<ul> <li>Auto-generated type definitions for the datasets have been regenerated [#37]. This pulls upstream changes from Uniprot. For a full list of changes view this commit diff.<ul> <li>Uniref's <code>created</code> <code>query</code> parameter has been replaced by <code>last_modified</code></li> <li>UniprotKB has lost various <code>fields</code>: <code>xref_genevisible</code>, <code>xref_dosac-cobs-2dpage\"</code>, <code>xref_swiss-2dpage</code>, <code>xref_ucd-2dpage</code>, <code>xref_world-2dpage</code>, <code>xref_epd</code>, <code>xref_maxqb</code>, <code>xref_ko</code> and <code>xref_genevisible</code></li> </ul> </li> </ul>"},{"location":"#130","title":"1.3.0","text":""},{"location":"#changed_1","title":"Changed","text":"<ul> <li>Auto-generated type definitions for the datasets have been regenerated [#31]. This pulls upstream changes from Uniprot. For a full list of changes view this commit diff.</li> <li>Auto-generated type definitions for the ID mapper have been regenerated [#30, @hlfernandez]</li> <li>Remove Python 3.7 support and support 3.12</li> </ul>"},{"location":"#120","title":"1.2.0","text":""},{"location":"#added_1","title":"Added","text":"<ul> <li><code>DatasetClient.search()</code> now has an <code>include_isoform</code> parameter, which specifies if you want isoforms to be returned [#27, @godotgildor]</li> <li>Python 3.11 is now officially supported</li> </ul>"},{"location":"#changed_2","title":"Changed","text":"<ul> <li>Auto-generated type definitions have been regenerated [#28]. This pulls upstream changes from Uniprot which are description-only:<ul> <li>All the <code>cc_</code> query fields for <code>Arba</code> and <code>Unirule</code> such as <code>cc_cofactor</code> and <code>cc_domain</code> hav updated descriptions</li> <li><code>Uniparc</code>'s list of databases has increased in the <code>database</code> query field</li> </ul> </li> </ul>"},{"location":"#110","title":"1.1.0","text":""},{"location":"#changed_3","title":"Changed","text":"<ul> <li><code>unipressed.IdMappingClient.get_status()</code> now returns a <code>Literal</code>, which gives your type checker/IDE access to the possible return values.</li> </ul>"},{"location":"#fixed","title":"Fixed","text":"<ul> <li><code>unipressed.IdMappingClient.get_status()</code> now wraps a bug in the UniProt API (#293), ensuring that it will return a valid job status even when the API itself does not. [#21]</li> </ul>"},{"location":"#100","title":"1.0.0","text":""},{"location":"#changed_4","title":"Changed","text":"<ul> <li>Breaking: Reworked the search API. Broadly this means that rather than using <code>unipressed.UniprotkbSearch</code>, you should now use the <code>unipressed.UniprotkbClient</code> class, which encapsulates the dataset's APIs. You can then perform a search query using <code>Uniprotkb.search()</code>.</li> <li>Breaking: Restructured the Python package. Most imports have changed.</li> </ul>"},{"location":"#added_2","title":"Added","text":"<ul> <li>The new client objects support <code>.fetch_one()</code> and <code>.fetch_many()</code> which can be used to look up one or more database entries using their IDs</li> <li>An ID mapping client. This can be accessed as <code>unipressed.IdMappingClient</code></li> </ul>"},{"location":"#020","title":"0.2.0","text":"<p>Note, if you are using Visual Studio Code, please update Pylance to at least version 2022.8.20. A bug in earlier versions will give you false errors with this new release of <code>unipressed</code>.</p>"},{"location":"#added_3","title":"Added","text":"<ul> <li> <p>Also allow strings within the query dictionary, so that e.g. this is now allowed:     <pre><code>{\n    \"and_\": [\n        \"foo*\",\n        \"*bar\"\n    ]\n}\n</code></pre>     This will search for all proteins that have any field that starts with <code>foo</code> and any field that ends with <code>bar</code>.</p> </li> <li> <p>Auto generated docstrings for all fields</p> </li> <li>Examples to the documentation of each field</li> <li>Certain missing query fields for the <code>arba</code> dataset:<ul> <li><code>cc_scl_term</code></li> </ul> </li> <li>Certain missing query fields for the <code>proteomes</code> dataset:<ul> <li><code>organism_id</code></li> <li><code>taxonomy_id</code></li> </ul> </li> <li>Certain missing query fields for the <code>unirule</code> dataset:<ul> <li><code>cc_scl_term</code></li> </ul> </li> <li>Certain missing query fields for the <code>uniparc</code> dataset:<ul> <li><code>taxonomy_id</code></li> </ul> </li> <li>Certain missing query fields for the <code>uniprotkb</code> dataset:<ul> <li><code>organism_id</code></li> <li><code>taxonomy_id</code></li> <li><code>virus_host_id</code></li> </ul> </li> </ul>"},{"location":"#removed","title":"Removed","text":"<ul> <li>Uniprot seem to have removed certain <code>uniprokb</code> query fields, so these are now not part of the accepted query type:<ul> <li><code>ft_metal</code></li> <li><code>ftlen_metal</code></li> <li><code>ft_ca_bind</code></li> <li><code>ftlen_ca_bind</code></li> <li><code>ft_np_bind</code></li> <li><code>ftlen_np_bind</code></li> </ul> </li> <li>Likewise, some <code>uniprotkb</code> return fields have been removed:<ul> <li><code>ft_ca_bind</code></li> <li><code>ft_metal</code></li> <li><code>ft_np_bind</code></li> </ul> </li> </ul>"},{"location":"#internal","title":"Internal","text":"<ul> <li>Move from <code>pyhumps</code> to <code>inflection</code> for code generation</li> <li>Add a test for the date field</li> <li>Added tests for all datasets</li> <li>Add types for code generation API</li> </ul>"}]}